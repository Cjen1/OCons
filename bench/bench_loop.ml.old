open Ocamlpaxos
open Lwt.Infix

let src = Logs.Src.create "Bench"

module Log = (val Logs.src_log src : Logs.LOG)

let node_address =
  ( Int64.of_int 1
  , Unix_capnp_messaging.Conn_manager.addr_of_string "127.0.0.1:5000"
    |> Result.get_ok )

let log_path, term_path = ("tmp.log", "tmp.term")

let time_it f =
  let start = Unix.gettimeofday () in
  f () >>= fun () -> Unix.gettimeofday () -. start |> Lwt.return

let throughput n request_batching =
  Log.info (fun m -> m "Setting up throughput test") ;
  Client.new_client [node_address] ()
  >>= fun client ->
  let test_data = Bytes.of_string "asdf" in
  Client.op_write client test_data test_data
  >>= fun _ ->
  let stream =
    List.init n (fun _ -> Bytes.(of_string "asdf", of_string "asdf"))
    |> Lwt_stream.of_list
  in
  let result_q = Queue.create () in
  let test () =
    Lwt_stream.iter_p
      (fun (key, value) ->
        let start = Unix.gettimeofday () in
        Client.op_write client key value
        >|= function
        | Error (`Msg s) ->
            Log.err (fun m -> m "Failed with %s during run" s)
        | Ok _ ->
            let time = Unix.gettimeofday () -. start in
            Queue.add time result_q)
      stream
  in
  Log.info (fun m -> m "Starting throughput test") ;
  time_it test
  >>= fun time ->
  Log.info (fun m -> m "Closing managers") ;
  Client.close client
  >|= (fun () -> Unix.unlink log_path ; Unix.unlink term_path)
  >>= fun () ->
  Log.info (fun m -> m "Finished throughput test!") ;
  let res_str = Base.Float.(of_int n / time) in
  Lwt.return
    (res_str, request_batching, Queue.fold (fun ls e -> e :: ls) [] result_q)

type test_res = {throughput: float; batch: int; latencies: float array}

let server request_batching = 
  let run = 
    Log.info (fun m -> m "Starting server on %a" Unix_capnp_messaging.Conn_manager.pp_addr (snd node_address));
    Infra.create ~listen_address:(snd node_address) ~node_list:[node_address]
      ~election_timeout:5 ~tick_time:0.5 ~log_path ~term_path (fst node_address)
      ~request_batching
    >>= fun node ->
    let close_flag, ful = Lwt.task () in 
    Lwt_unix.on_signal Sys.sigusr1 (fun _ -> Lwt.wakeup ful ()) |> ignore;
    close_flag >>= fun () ->
    Log.info (fun m -> m "Closing server");
    Infra.close node
  in 
  Lwt_main.run run

let tests () =
  let run batch = 
    Log.info (fun m -> m "Running test for batch %d" batch);
    match Unix.fork () with
    | 0 -> (*child*)
      server batch;
      exit 0
    | cpid ->
      Lwt_unix.on_signal Sys.sigterm (fun _ -> Unix.kill cpid Sys.sigusr1; exit 0) |> ignore;
      let res = Lwt_main.run (throughput 10000 batch) in
      Unix.kill cpid Sys.sigusr1;
      res
  in 
  let process (throughput, batch, latencies) =
    let latencies = latencies |> Array.of_list in
    {throughput; batch; latencies}
  in
  let batch_sizes =
    List.init 5 Base.(fun x -> Float.(10. ** of_int x) |> Float.to_int)
  in
  List.map run batch_sizes
  |> List.map process |> Lwt.return

let reporter =
  let open Core in
  let report src level ~over k msgf =
    let k _ = over () ; k () in
    let src = Logs.Src.name src in
    msgf
    @@ fun ?header ?tags:_ fmt ->
    Fmt.kpf k Fmt.stdout
      ("[%a] %a %a @[" ^^ fmt ^^ "@]@.")
      Time.pp (Time.now ())
      Fmt.(styled `Magenta string)
      (Printf.sprintf "%14s" src)
      Logs_fmt.pp_header (level, header)
  in
  {Logs.report}

let pp_stats f stats =
  let open Owl.Stats in
  let mean = mean stats.latencies in
  let p50 = percentile stats.latencies 50. in
  let p75 = percentile stats.latencies 75. in
  let p99 = percentile stats.latencies 99. in
  Fmt.pf f "batch:%d, throughput:%fops/s@[<v>mean:%f@p50:%f@p75:%f@p99:%f]@"
    stats.batch stats.throughput mean p50 p75 p99

let () =
  Logs.(set_level ~all:true (Some Debug)) ;
  (*List.iter
    (fun src -> Logs.Src.set_level src (Some Info))
    [Unix_capnp_messaging.Conn_manager.src; Unix_capnp_messaging.Sockets.src] ;
    *)
  Logs.set_reporter reporter ;
  let res = Lwt_main.run (tests ()) in
  Fmt.pr "%a" (Fmt.list pp_stats) res
